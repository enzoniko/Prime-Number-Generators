\section{Introduction}

Prime numbers are fundamental to modern cryptography, securing digital systems through protocols like RSA and elliptic curve cryptography \cite{rivest1978, crandall2005}. Generating the large primes required (e.g., 2048-bit for Brazilian digital signatures \cite{MP2200-2-2001, ITI-04-2005}) involves two key challenges: producing suitable random candidate numbers and efficiently verifying their primality. These challenges are amplified in resource-constrained environments (e.g., IoT devices) where computational power and memory are limited \cite{resource_constrained, prng_iot}, demanding careful algorithm selection based on both theoretical guarantees and practical performance.

This document explores pseudo-random number generation (PRNG) and primality testing, focusing on their application in such constrained systems.

\subsection{Project Objectives}

The main objectives are:

\begin{itemize}
    \item Implement large-integer (up to 4096 bits) PRNGs (LCG, Xoshiro256++) and primality tests (Miller-Rabin, Baillie-PSW).
    \item Benchmark performance (time, memory) for resource-constrained contexts.
    \item Analyze algorithm trade-offs (speed, resources, security).
    \item Provide a reusable, resource-efficient C++ library for these primitives.
\end{itemize}

\subsection{Significance in Resource-Constrained Systems}

Efficient cryptography is crucial for resource-constrained systems \cite{embedded_prng}. While standard algorithm performance is well-studied, their behavior under resource limitations requires specific investigation. This project addresses this by providing optimized C++ implementations utilizing the GMP library \cite{granlund2012}, rigorous benchmarking (time, memory), scalability analysis, bottleneck identification, and practical recommendations based on empirical data.

\subsection{Document Structure}

This document is organized as follows. Section 2 describes the repository structure and the organization of the codebase. Section 3 focuses on random number generation, detailing the algorithms implemented and their theoretical foundations, with particular attention to their suitability for resource-constrained systems. Following this, Section 4 explores primality testing algorithms, their mathematical basis, and implementation details, emphasizing optimizations for efficiency. Section 5 explains the experimental methodology used to evaluate algorithm performance, including our approach to measuring energy consumption. The results of our experiments and comparative analysis are presented in Section 6, providing empirical data on execution time, memory usage, and energy efficiency. Finally, Section 7 concludes the document, synthesizes our findings, and suggests potential future work.